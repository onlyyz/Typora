---
author: zhurong
create: 2022-11-03 11:12
last-modify: 2022-11-03 11:12
aliases: []
tags: []
---

***
## 概览
我们通常使用法线贴图在物体表面构造细节，但是法线贴图只添加了物体表面的法线细节，无法添加物体表面的凹凸细节，所以 UV 还是按照本来的 UV 去采样，这样子就会导致画面看起来比较的 “平”，这时候，我们引入一张高度图，然后利用这张高度图对 UV 进行偏移，以此来增加表面的立体感，这种方法就被称之为 Parallax Mapping 或 Bump Mapping。

***
## 基本 Parallax Mapping
### 使用相似三角形
导致平面细节损失的原因是我们采样了错误的 UV，得到了错误的颜色值，那么基础的想法就是将这个误差去加回来在不考虑视线与表面相交物理正确的前提下，我们可以使用以下公式来执行这个缩放。
$$
UV =  UV + \frac{dir.xy}{dir.z} * (height * heightScale)
$$
其中 $dir$ 为视线方向，$height$ 是采样获得的高度，$heightScale$ 是传入的一个缩放值，用来控制位移距离；公式中通过 $dir.xy / dir.z$ 来获得一个 Tangent 值，再通过乘上高度，构造了一个相似三角，由于构造的相似三角相当于假定了经过位移后的目标点与当前点处于同一平面（高度），所以，这种方法比较适合**较为平缓的表面**。

### 针对较为陡峭的表面
使用相似，我们可以得到一个近似的位移量，但是我们引入了两个问题：
1. 只能在相对平缓的表面工作良好
2. 在接近掠射角的时候，offset 会变成一个非常大的值

我们可以使用一些方法来尝试纠正这个问题：
1. 从等式中去除 dir. z，这种做法相当于以视线和平面的交点为圆心，构造了一个单位圆，并假设位移后的落点在这个圆上，提升了对表面的陡峭程度的假设。
	> 针对「构造了一个单位圆」，请想象视线从垂直转到平行，我们计算的落点形成了一条轨迹，对于原公式，我们的落点化了一条平直的线，对于去除了 $dir.z$ 的公式，我们计算的落点形成了一个单位圆。
1. 第一步对表面陡峭程度的假设一成不变，其原因是我们使用的是一个单位圆，通过控制这个圆的半径，我们可以控制其陡峭程度，其实原公式的陡峭程度曲线就是 $1/dir.z$，其在 $z$ 趋向于 0 的时候，趋向于无限大，这就导致了它的轨迹为一个平面，我们可以改变一下公式，比如使用 $exp (-dir. z + a) + b$ 来控制半径的变化，以此来控制陡峭的程度，其中 $b$ 可以由 $-exp (-1 + a) + 1$ 算出。

### 「锚」面
由于 $height$ 是一个 Clamp 到 $[0, 1]$ 区间中的值，我们假定的「锚点」平面在最顶端，所以我们会有一种「物体在画里面动」的感觉，通过重映射 $height$ 的区间，我们可以改变 「锚面」的位置，如下：
$$
UV =  UV + \frac{dir.xy}{dir.z} * ((height - 0.5) * 2 * heightScale)
$$
通过 $(height-0.5)*2$，我们将位移区间从 $[0, 1]$ 移动到了 $[-1, 1]$，让处于浅处的像素有一个负的位移，来营造一种画面物体的摆动感。

### 问题
这种方式计算量少，但是并没有考虑物理正确的相交，而是通过一个函数来假定陡峭表面的位置，效果会显得相对粗糙，也就是「太平」

***
## 陡峭视差映射 Steep Parallax Mapping (SPM)
### 思路
上述的方法都在对表面进行一个函数式的假定，并没有处理与平面的正确相交，SPM 从一定程度上解决了这个问题，它将视线的射入部分分成了 n 段落，每次进行一次采样，如果当前采样的深度高于视线的深度，那么就停止采样并返回结果。

### 问题
- 更多的采样结果可以得到更好的效果，但是开销会变的更大
- 分层过少会产生很严重的锯齿感

***
## 视差遮蔽映射 Parallax Occlusion Mapping (POM)
### 思路
在 SPM 中，我们直接返回了最后一次的结果，这也导致了一定的锯齿感，其实，我们可以假设我们处于一个**斜率大概一致**的斜面上，通过与上一次结果的插值来求解一个近似表面的位移值，即求解以下的等式：
$$
lerp(curDir.z, lastDir.z, t) = lerp(curHeight, lastHeight, t)
$$
即
$$
t = \frac{curHeight}{((lastDir.z -lastHeight) - (curDir - curHeight)) * curDir.z} 
$$
这样可以得到一个相对不错的效果。

### 问题
- 虽然使用插值优化了锯齿感，但是质量还是高度依赖于采样次数
- 由于使用了插值，假定两次采样点斜率一致，会导致无法表达一些深度突变的尖锐特性（这种特性本身就依赖于采样次数）

***
## 浮雕映射 Relief Parallax Mapping (RPM)
### 思路
POM 使用了插值的做法来进行位置估计，由于假设两个采样点的斜率保持一致，得到的结果可能无法表示一些极为陡峭的情况，于是，我们使用二分查找的方式，去细化这个区间，逼近交点处的真正斜率，以此来获得更好的细节

### 问题
虽然 RPM 的效果最好，但是消耗依旧非常可观，并且如果初始采样数给的太大，二分容易给出错误的结果，造成物体表面的突变与闪烁。

***
## 总结
- 在追求效果的情况下，使用 [[#浮雕映射 Relief Parallax Mapping (RPM)|RPM]]
- 在妥协效果换取性能的情况下，使用 [[#视差遮蔽映射 Parallax Occlusion Mapping (POM)|POM]]
- 在追求高性能的情况下，使用 [[#基本 Parallax Mapping]]

***
## Reference
- [视差映射（Parallax Mapping） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/164754522)
- [从0开始的技术美术之路（十二）Bump Mapping（凹凸贴图映射技术）](https://blog.csdn.net/qq_43210334/article/details/117774643)
- [Inside Facebook 3D Photos: Parallax Shaders - Alan Zucconi](https://www.alanzucconi.com/2019/01/01/facebook-3d-photos/)
- [Parallax Shaders & Depth Maps - Alan Zucconi](https://www.alanzucconi.com/2019/01/01/parallax-shader/)